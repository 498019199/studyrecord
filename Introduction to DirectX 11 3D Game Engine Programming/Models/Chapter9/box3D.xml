<?xml version='1.0'?>
<effect>
    <include name="Lighting.fxml"/>
    <cbuffer name="VSConstantBuffer">
        <parameter type="float4x4" name="world"/>
        <parameter type="float4x4" name="view"/>
        <parameter type="float4x4" name="projection"/>
    </cbuffer>
    <cbuffer name="PSConstantBuffer">
        <parameter type="DirectionalLight" name="directional_light"/>
        <parameter type="PointLight" name="point_light"/>
        <parameter type="SpotLight" name="spot_light"/>
        <parameter type="Material" name="material"/>
        <parameter type="float" name="eyePos"/>
    </cbuffer>

    <parameter type="texture2D" name="src1_tex"/>
	<parameter type="sampler" name="point_sampler">
		<state name="filtering" value="min_mag_mip_point"/>
		<state name="address_u" value="clamp"/>
		<state name="address_v" value="clamp"/>
	</parameter>

    <technique name="Basic_3D">
        <pass name="p0">
            <state name="cull_mode" value="front"/>

            <state name="blend_enable" value="true"/>
			<state name="blend_op" value="add"/>
			<state name="src_blend" value="one"/>
			<state name="dest_blend" value="one"/>
			<state name="blend_op_alpha" value="add"/>
			<state name="src_blend_alpha" value="one"/>
			<state name="dest_blend_alpha" value="one"/>

            <state name="vertex_shader" value="VS()"/>
			<state name="pixel_shader" value="PS()"/>
        </pass>
    </technique>
    <shader>
        		<![CDATA[

struct VertexIn
{
    float3 posL : POSITION;
    float3 normalL : NORMAL;
    float2 tex : TEXCOORD;
};

VertexOut VS(VertexIn vIn)
{
    VertexOut vOut;
    matrix viewProj = mul(gView, gProj);
    float4 posW = mul(float4(vIn.posL, 1.0f), gWorld);

    vOut.posH = mul(posW, viewProj);
    vOut.posW = posW.xyz;
    vOut.normalW = mul(vIn.normalL, (float3x3) gWorldInvTranspose);

    // 旋转
    vOut.tex2 = mul(float4(vIn.tex, 0.f, 1.f), gRotateM);
    vOut.tex1 = vIn.tex;
    return vOut;
}

// 像素着色器
float4 PS(VertexOut pIn) : SV_Target
{
    // 标准化法向量
    pIn.normalW = normalize(pIn.normalW);
    // 顶点指向眼睛的向量
    float3 toEyeW = normalize(gEyePosW - pIn.posW);

    // 初始化为0 
    float4 ambient, diffuse, spec;
    float4 A, D, S;
    ambient = diffuse = spec = A = D = S = float4(0.0f, 0.0f, 0.0f, 0.0f);

    ComputeDirectionalLight(gMaterial, gDirLight, pIn.normalW, toEyeW, A, D, S);
    ambient += A;
    diffuse += D;
    spec += S;

    ComputePointLight(gMaterial, gPointLight, pIn.posW, pIn.normalW, toEyeW, A, D, S);
    ambient += A;
    diffuse += D;
    spec += S;

    ComputeSpotLight(gMaterial, gSpotLight, pIn.posW, pIn.normalW, toEyeW, A, D, S);
    ambient += A;
    diffuse += D;
    spec += S;

    float4 texColor = gTex1.Sample(gSamLinear1, pIn.tex1);
    float4 litColor = texColor * (ambient + diffuse) + spec;
    litColor.a = texColor.a * gMaterial.Diffuse.a;
    return litColor;
}

struct VertexOut
{
    float4 posH : SV_POSITION;
    float3 posW : POSITION;     // 在世界中的位置
    float3 normalW : NORMAL;    // 法向量在世界中的方向
    float2 tex1 : TEXCOORD;
    float2 tex2 : TEXCOORD;
};
            		]]>
    </shader>
</effect>